// Generated by CoffeeScript 2.4.1
(function() {
  var Bar, FS_Plot, Point, enumerate, getTime, textMesh;

  enumerate = function(x) {
    var ref;
    return _.zip((function() {
      var results = [];
      for (var j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this), x);
  };

  getTime = function() {
    return new Date() * 1e-3;
  };

  textMesh = function(text, style) {
    var mesh;
    mesh = new PIXI.Text(text, style);
    mesh.anchor.set(0.5, 0.5);
    return mesh;
  };

  Point = class Point {
    static ease(p) {
      return (1 - Math.cos(Math.min(1, Math.max(0, p)) * Math.PI)) / 2;
    }

    static blend(a, b, weight) {
      return (1 - weight) * a + weight * b;
    }

    constructor(mesh1, loc) {
      this.mesh = mesh1;
      [this.src, this.dst] = [loc, loc];
    }

    setTarget(target, p = 1) {
      var weight, x, y;
      weight = Point.ease(p);
      x = Point.blend(this.src.x, this.dst.x, weight);
      y = Point.blend(this.src.y, this.dst.y, weight);
      return [this.src, this.dst] = [new PIXI.Point(x, y), target];
    }

    update(p, w, h) {
      var weight;
      weight = Point.ease(p);
      this.mesh.position.x = w * Point.blend(this.src.x, this.dst.x, weight);
      return this.mesh.position.y = h * Point.blend(this.src.y, this.dst.y, weight);
    }

  };

  Bar = class Bar {
    constructor() {
      [this.src, this.dst] = [
        {
          mean: 0,
          std: 0
        },
        {
          mean: 0,
          std: 0
        }
      ];
    }

    setTarget(mean, std, p = 1) {
      var mean0, std0, weight;
      weight = Point.ease(p);
      mean0 = Point.blend(this.src.mean, this.dst.mean, weight);
      std0 = Point.blend(this.src.std, this.dst.std, weight);
      return [this.src, this.dst] = [
        {
          mean: mean0,
          std: std0
        },
        {
          mean: mean,
          std: std
        }
      ];
    }

    draw(p, plot, color, x, y, w, h) {
      var bar, barBottom, barMean, barTop, mean, ref, std, weight;
      weight = Point.ease(p);
      mean = Point.blend(this.src.mean, this.dst.mean, weight);
      std = Point.blend(this.src.std, this.dst.std, weight);
      barMean = y + plot.getY(mean, p) * h;
      barBottom = y + plot.getY(mean - std, p) * h;
      barTop = y + plot.getY(mean + std, p) * h;
      bar = new PIXI.Graphics();
      bar.lineStyle(0, 0, 0);
      bar.beginFill(color, 0.5);
      bar.drawRect(x - w / 2, barBottom, w, barTop - barBottom);
      bar.endFill();
      bar.lineStyle(3, color, 1);
      bar.moveTo(x - w / 2, barMean);
      bar.lineTo(x + w / 2, barMean);
      if ((ref = bar.currentPath) != null ? ref.shape : void 0) {
        bar.currentPath.shape.closed = false;
      }
      return bar;
    }

  };

  (typeof exports !== "undefined" && exports !== null ? exports : window).FS_Plot = FS_Plot = (function() {
    class FS_Plot {
      constructor(canvas, teams1) {
        var count, ew, graphics, i, j, k, l, len, len1, len2, len3, len4, m, mesh, n, options, point0, ref, ref1, ref2, ref3, ref4, ref5, style, team, y_label;
        this.teams = teams1;
        // xTicks, requires FS_Data to be initialized
        this.xTicks = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = FS_Data.epiweeks.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            results.push((i + 0.5) / FS_Data.epiweeks.length);
          }
          return results;
        })();
        // renderer setup
        [this.w, this.h] = [canvas.width(), canvas.height()];
        options = {
          view: canvas[0],
          antialias: true
        };
        this.renderer = new PIXI.autoDetectRenderer(this.w, this.h, options);
        this.renderer.backgroundColor = 0xffffff;
        // coloring
        this.teamColors = {};
        ref = enumerate(this.teams);
        for (j = 0, len = ref.length; j < len; j++) {
          [i, team] = ref[j];
          this.teamColors[team] = FS_Plot.colors[i % FS_Plot.colors.length];
        }
        // point for each epiweek for each team
        this.showPoints = false;
        this.showLegend = true;
        this.stageTeamPoints = {};
        point0 = new PIXI.Point(0.5, 0.5);
        this.points = {};
        ref1 = this.teams;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          team = ref1[k];
          this.points[team] = [];
          this.stageTeamPoints[team] = new PIXI.Container();
          count = 0;
          ref2 = FS_Data.epiweeks;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            ew = ref2[l];
            graphics = new PIXI.Graphics();
            graphics.beginFill(this.teamColors[team], 1);
            graphics.lineStyle(2, 0x000000, 1);
            graphics.drawCircle(0, 0, 4);
            //graphics.drawRect(-4, -4, 8, 8)
            graphics.endFill();
            this.stageTeamPoints[team].addChild(graphics);
            this.points[team].push(new Point(graphics, point0));
            count = count + 1;
          }
        }
        // order in which lines are drawn
        this.lineOrder = (function() {
          var results = [];
          for (var m = 0, ref3 = this.teams.length; 0 <= ref3 ? m < ref3 : m > ref3; 0 <= ref3 ? m++ : m--){ results.push(m); }
          return results;
        }).apply(this);
        // bar for each team
        this.teamBars = [];
        ref4 = this.teams;
        for (m = 0, len3 = ref4.length; m < len3; m++) {
          team = ref4[m];
          this.teamBars.push(new Bar());
        }
        // plot initial values
        this.renderRequested = false;
        this.lastMode = this.mode = 'line';
        [this.plotMin, this.plotMax] = [-1, +1];
        // axis stuff
        [this.dataMin, this.dataMax] = [-1, +1];
        [this.axisMin, this.axisMax] = [-1.1, +1.1];
        y_label = textMesh('AE/LS', FS_Plot.labelStyle);
        this.axisLabels = {
          line: {
            x: textMesh('Epiweek', FS_Plot.labelStyle),
            y: y_label
          },
          bar: {
            x: textMesh('Team', FS_Plot.labelStyle),
            y: y_label
          }
        };
        this.axisTicks = {
          line: {
            x: (function() {
              var len4, n, ref5, results;
              ref5 = FS_Data.epiweeks;
              results = [];
              for (n = 0, len4 = ref5.length; n < len4; n++) {
                ew = ref5[n];
                results.push(textMesh('' + ew, FS_Plot.tickStyle));
              }
              return results;
            })()
          },
          bar: {
            x: (function() {
              var len4, n, ref5, results;
              ref5 = this.teams;
              results = [];
              for (n = 0, len4 = ref5.length; n < len4; n++) {
                team = ref5[n];
                results.push(textMesh(team, FS_Plot.tickStyle));
              }
              return results;
            }).call(this)
          }
        };
        // legend
        this.legend = new PIXI.Container();
        ref5 = enumerate(this.teams);
        for (n = 0, len4 = ref5.length; n < len4; n++) {
          [i, team] = ref5[n];
          style = {
            font: FS_Plot.tickStyle.font,
            fill: this.teamColors[team]
          };
          mesh = textMesh(team, style);
          mesh.position.set(mesh.width / 2, 16 * (i + 1));
          this.legend.addChild(mesh);
        }
        // wILI overlay
        this.wILI = null;
        // timing
        this.animationStartTime = getTime();
      }

      requestRender() {
        if (this.renderRequested) {
          return;
        }
        this.renderRequested = true;
        return requestAnimationFrame((renderTime) => {
          return this.render(renderTime);
        });
      }

      render(renderTime) {
        var alpha, animationProgress, axes, b, bar, color, dataMax, dataMin, h, i, j, k, l, len, len1, len2, len3, len4, len5, line, lineWidth, m, n, o, overlay, p, plotBox, pts, q, r, range, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, stageLines, stageMain, stagePlot, str, t, team, teamIndex, tickLabel, tickLabels, u, value, w, weight, x, x0, x1, xBox, y, y0, y1, yBox;
        this.renderRequested = false;
        // queue next frame
        animationProgress = (getTime() - this.animationStartTime) / FS_Plot.animationDuration;
        if (animationProgress < 1) {
          this.requestRender();
        }
        // various sections of the screen
        yBox = {
          x: 0,
          y: 0,
          w: 64,
          h: this.h
        };
        plotBox = {
          x: yBox.w,
          y: 0,
          w: this.w - yBox.w,
          h: this.h - 32
        };
        xBox = {
          x: plotBox.x,
          y: plotBox.y + plotBox.h,
          w: this.w - plotBox.x,
          h: this.h - (plotBox.y + plotBox.h)
        };
        stagePlot = new PIXI.Container();
        stagePlot.position.set(plotBox.x, plotBox.y);
        // wILI overlay
        if (this.wILI !== null && this.wILI.length > 0) {
          line = new PIXI.Graphics();
          line.lineStyle(3, 0x000000, 0.25);
          for (i = j = 1, ref = this.wILI.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
            h = i - 1;
            x0 = this.xTicks[h] * plotBox.w;
            x1 = this.xTicks[i] * plotBox.w;
            y0 = this.getY(Point.blend(this.dataMin, this.dataMax, this.wILI[h])) * plotBox.h;
            y1 = this.getY(Point.blend(this.dataMin, this.dataMax, this.wILI[i])) * plotBox.h;
            line.moveTo(x0, y0);
            line.lineTo(x1, y1);
            if ((ref1 = line.currentPath) != null ? ref1.shape : void 0) {
              line.currentPath.shape.closed = false;
            }
          }
          stagePlot.addChild(line);
        }
        ref2 = this.teams;
        // animate points
        for (k = 0, len = ref2.length; k < len; k++) {
          t = ref2[k];
          ref3 = this.points[t];
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            p = ref3[l];
            p.update(animationProgress, plotBox.w, plotBox.h);
          }
        }
        // lines through points
        stageLines = new PIXI.Container();
        ref4 = this.lineOrder;
        for (m = 0, len2 = ref4.length; m < len2; m++) {
          teamIndex = ref4[m];
          team = this.teams[teamIndex];
          line = new PIXI.Graphics();
          alpha = this.showPoints ? 0.75 : 1;
          line.lineStyle(3, this.teamColors[team], alpha);
          pts = this.points[team];
          for (i = n = 1, ref5 = pts.length; (1 <= ref5 ? n < ref5 : n > ref5); i = 1 <= ref5 ? ++n : --n) {
            h = i - 1;
            line.moveTo(pts[h].mesh.position.x, pts[h].mesh.position.y);
            line.lineTo(pts[i].mesh.position.x, pts[i].mesh.position.y);
            if ((ref6 = line.currentPath) != null ? ref6.shape : void 0) {
              line.currentPath.shape.closed = false;
            }
          }
          stageLines.addChild(line);
        }
        stagePlot.addChild(stageLines);
        // draw points on top of lines
        if (this.showPoints) {
          ref7 = this.lineOrder;
          for (o = 0, len3 = ref7.length; o < len3; o++) {
            teamIndex = ref7[o];
            stagePlot.addChild(this.stageTeamPoints[this.teams[teamIndex]]);
          }
        }
        //# axis labels
        //x_label = @axisLabels[@mode].x
        //x_label.position.set(@w / 2, @h - 24)
        //y_label = @axisLabels[@mode].y
        //y_label.rotation = -Math.PI / 2
        //y_label.position.set(24, @h / 2)
        // axis decoration
        tickLabels = new PIXI.Container();
        axes = new PIXI.Graphics();
        overlay = new PIXI.Graphics();
        axes.lineStyle(3, 0x000000, 1);
        x0 = xBox.x + this.xTicks[0] * xBox.w;
        x1 = xBox.x + this.xTicks[this.xTicks.length - 1] * xBox.w;
        y0 = plotBox.y + this.getY(this.dataMin) * plotBox.h;
        y1 = plotBox.y + this.getY(this.dataMax) * plotBox.h;
        // axis bars
        axes.moveTo(plotBox.x, y0);
        axes.lineTo(plotBox.x, y1);
        axes.moveTo(x0, xBox.y);
        axes.lineTo(x1, xBox.y);
        if ((ref8 = axes.currentPath) != null ? ref8.shape : void 0) {
          axes.currentPath.shape.closed = false;
        }
        // y ticks and grid lines
        weight = Point.ease(animationProgress);
        dataMin = Point.blend(this.lastDataMin, this.dataMin, weight);
        dataMax = Point.blend(this.lastDataMax, this.dataMax, weight);
        this.interval = 1;
        range = dataMax - dataMin;
        while (this.interval >= 0.01 && range / this.interval < 6) {
          this.interval *= 0.5;
        }
        while (this.interval < 100 && range / this.interval >= 12) {
          this.interval *= 2;
        }
        for (i = q = 0, ref9 = range / this.interval; (0 <= ref9 ? q <= ref9 : q >= ref9); i = 0 <= ref9 ? ++q : --q) {
          value = this.dataMin + i * this.interval;
          x = plotBox.x;
          y = plotBox.y + this.getY(value, animationProgress) * plotBox.h;
          str = value.toFixed(2);
          while (str.indexOf('.') >= 0 && (str.endsWith('0') || str.endsWith('.'))) {
            str = str.substring(0, str.length - 1);
          }
          tickLabel = textMesh(str, FS_Plot.tickStyle);
          tickLabel.position.set(x - tickLabel.width / 2 - 15, y);
          tickLabels.addChild(tickLabel);
          axes.lineStyle(1, 0x000000, 0.1);
          axes.moveTo(x0, y);
          axes.lineTo(x1, y);
          axes.lineStyle(3, 0x000000, 1);
          axes.moveTo(x, y);
          axes.lineTo(x - 10, y);
        }
        // x ticks and grid lines
        if (this.mode === 'line') {
          for (i = r = 0, ref10 = FS_Data.epiweeks.length; (0 <= ref10 ? r < ref10 : r > ref10); i = 0 <= ref10 ? ++r : --r) {
            [x, y] = [xBox.x + this.xTicks[i] * xBox.w, xBox.y];
            if (i % 3 === 0) {
              lineWidth = 3;
              tickLabel = this.axisTicks[this.mode].x[i];
              tickLabel.position.set(x, y + 20);
              tickLabels.addChild(tickLabel);
            } else {
              lineWidth = 1;
            }
            axes.lineStyle(1, 0x000000, 0.1);
            axes.moveTo(x, y0);
            axes.lineTo(x, y1);
            if ((ref11 = axes.currentPath) != null ? ref11.shape : void 0) {
              axes.currentPath.shape.closed = false;
            }
            axes.lineStyle(lineWidth, 0x000000, 1);
            axes.moveTo(x, y);
            axes.lineTo(x, y + 10);
            if ((ref12 = axes.currentPath) != null ? ref12.shape : void 0) {
              axes.currentPath.shape.closed = false;
            }
          }
        } else {
          ref13 = enumerate(this.teams);
          for (s = 0, len4 = ref13.length; s < len4; s++) {
            [i, team] = ref13[s];
            [x, y] = [xBox.x + (i + 0.5) / this.teams.length * xBox.w, xBox.y];
            tickLabel = this.axisTicks[this.mode].x[i];
            tickLabel.position.set(x, y + 20);
            tickLabels.addChild(tickLabel);
            axes.lineStyle(1, 0x000000, 0.1);
            axes.moveTo(x, y0);
            axes.lineTo(x, y1);
            if ((ref14 = axes.currentPath) != null ? ref14.shape : void 0) {
              axes.currentPath.shape.closed = false;
            }
            axes.lineStyle(3, 0x000000, 1);
            axes.moveTo(x, y);
            axes.lineTo(x, y + 10);
            if ((ref15 = axes.currentPath) != null ? ref15.shape : void 0) {
              axes.currentPath.shape.closed = false;
            }
          }
        }
        // bars on top of the points
        if (this.mode !== 'line' || this.lastMode !== 'line') {
          ref16 = enumerate(this.teamBars);
          for (u = 0, len5 = ref16.length; u < len5; u++) {
            [i, bar] = ref16[u];
            [x, y] = [xBox.x + (i + 0.5) / this.teams.length * xBox.w, plotBox.y];
            [w, h] = [0.9 / this.teams.length * plotBox.w, plotBox.h];
            color = this.teamColors[this.teams[i]];
            p = animationProgress;
            b = bar.draw(p, this, color, x, y, w, h);
            if (this.lastMode !== this.mode) {
              if (this.mode === 'line') {
                // fade out
                p = 1 - animationProgress;
              } else {
                // fade in
                p = animationProgress;
              }
              b.alpha = Point.ease(p);
            } else {
              // no fade
              bar.alpha = 1;
            }
            overlay.addChild(b);
          }
        }
        // legend placement
        this.legend.position.set(plotBox.x + plotBox.w - this.legend.width - 8, plotBox.y);
        // put it all together
        stageMain = new PIXI.Container();
        //stageMain.addChild(x_label)
        //stageMain.addChild(y_label)
        stageMain.addChild(tickLabels);
        stageMain.addChild(axes);
        stageMain.addChild(stagePlot);
        stageMain.addChild(overlay);
        if (this.showLegend) {
          stageMain.addChild(this.legend);
        }
        // draw everything
        return this.renderer.render(stageMain);
      }

      update(teamValues, type = 'normal', teams, colors) {
        var animationProgress, center, count, diff, dist, ew, graphics, i, j, k, l, left, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, max, mesh, min, n, o, padding, point0, q, r, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, right, s, style, sum, t, team, teamIndex, u, v, value, weekIndex, width, x, y, z;
        this.teams = teams;
        this.colors = colors;
        // auto-adjust plot bounds
        [min, max] = [0, 0];
        this.teamAverages = {};
        this.teamStds = {};
        // bar for each team
        this.teamBars = [];
        ref = this.teams;
        for (j = 0, len = ref.length; j < len; j++) {
          team = ref[j];
          this.teamBars.push(new Bar());
        }
        ref1 = enumerate(this.teams);
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          [i, t] = ref1[k];
          sum = 0;
          ref2 = teamValues[t];
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            value = ref2[l];
            min = Math.min(min, value);
            max = Math.max(max, value);
            sum += value;
          }
          this.teamAverages[t] = sum / teamValues[t].length;
          sum = 0;
          ref3 = teamValues[t];
          for (m = 0, len3 = ref3.length; m < len3; m++) {
            value = ref3[m];
            sum += (value - this.teamAverages[t]) ** 2;
          }
          this.teamStds[t] = (sum / teamValues[t].length) ** 0.5;
          this.teamBars[i].setTarget(this.teamAverages[t], this.teamStds[t]);
        }
        if (type === 'zoomIn') {
          dist = this.dataMax - this.dataMin;
          diff = dist / 8.0;
          [min, max] = [this.dataMin + diff, this.dataMax - diff];
        }
        if (type === 'zoomOut') {
          dist = this.dataMax - this.dataMin;
          diff = dist * 2.0 / 3.0;
          [min, max] = [this.dataMin - this.interval, this.dataMax + this.interval];
        }
        if (type === 'moveUp') {
          dist = this.interval;
          [min, max] = [this.dataMin + dist, this.dataMax + dist];
        }
        if (type === 'moveDown') {
          dist = this.interval;
          [min, max] = [this.dataMin - dist, this.dataMax - dist];
        }
        if (type === 'teamToggle') {
          [min, max] = [this.dataMin, this.dataMax];
        }
        if (type === 'legendToggle') {
          this.showLegend = !this.showLegend;
          [min, max] = [this.dataMin, this.dataMax];
        }
        padding = (max - min) * 0.05;
        [this.lastDataMin, this.lastDataMax] = [this.dataMin, this.dataMax];
        [this.lastAxisMin, this.lastAxisMax] = [this.axisMin, this.axisMax];
        [this.dataMin, this.dataMax] = [min, max];
        [this.axisMin, this.axisMax] = [min - padding, max + padding];
        // coloring
        this.teamColors = {};
        ref4 = enumerate(this.teams);
        for (n = 0, len4 = ref4.length; n < len4; n++) {
          [i, team] = ref4[n];
          this.teamColors[team] = this.colors[i % this.colors.length];
        }
        // order in which lines are drawn
        this.lineOrder = (function() {
          var results = [];
          for (var o = 0, ref5 = this.teams.length; 0 <= ref5 ? o < ref5 : o > ref5; 0 <= ref5 ? o++ : o--){ results.push(o); }
          return results;
        }).apply(this);
        this.stageTeamPoints = {};
        point0 = new PIXI.Point(0.5, 0.5);
        this.points = {};
        ref6 = this.teams;
        for (o = 0, len5 = ref6.length; o < len5; o++) {
          team = ref6[o];
          this.points[team] = [];
          this.stageTeamPoints[team] = new PIXI.Container();
          count = 0;
          ref7 = FS_Data.epiweeks;
          for (q = 0, len6 = ref7.length; q < len6; q++) {
            ew = ref7[q];
            graphics = new PIXI.Graphics();
            graphics.beginFill(this.teamColors[team], 1);
            graphics.lineStyle(2, 0x000000, 1);
            graphics.drawCircle(0, 0, 4);
            //graphics.drawRect(-4, -4, 8, 8)
            graphics.endFill();
            if (teamValues[team][count] >= min) {
              this.stageTeamPoints[team].addChild(graphics);
            }
            this.points[team].push(new Point(graphics, point0));
            count = count + 1;
          }
        }
        this.axisTicks = {
          line: {
            x: (function() {
              var len7, r, ref8, results;
              ref8 = FS_Data.epiweeks;
              results = [];
              for (r = 0, len7 = ref8.length; r < len7; r++) {
                ew = ref8[r];
                results.push(textMesh('' + ew, FS_Plot.tickStyle));
              }
              return results;
            })()
          },
          bar: {
            x: (function() {
              var len7, r, ref8, results;
              ref8 = this.teams;
              results = [];
              for (r = 0, len7 = ref8.length; r < len7; r++) {
                team = ref8[r];
                results.push(textMesh(team, FS_Plot.tickStyle));
              }
              return results;
            }).call(this)
          }
        };
        // legend
        this.legend = new PIXI.Container();
        ref8 = enumerate(this.teams);
        for (r = 0, len7 = ref8.length; r < len7; r++) {
          [i, team] = ref8[r];
          style = {
            font: FS_Plot.tickStyle.font,
            fill: this.teamColors[team]
          };
          mesh = textMesh(team, style);
          mesh.position.set(mesh.width / 2, 16 * (i + 1));
          this.legend.addChild(mesh);
        }
        // set point targets
        animationProgress = (getTime() - this.animationStartTime) / FS_Plot.animationDuration;
        if (this.mode === 'line') {
          for (i = s = 0, ref9 = FS_Data.epiweeks.length; (0 <= ref9 ? s < ref9 : s > ref9); i = 0 <= ref9 ? ++s : --s) {
            x = this.xTicks[i];
            ref10 = this.teams;
            for (u = 0, len8 = ref10.length; u < len8; u++) {
              t = ref10[u];
              y = this.getY(teamValues[t][i]);
              this.points[t][i].setTarget(new PIXI.Point(x, y), animationProgress);
            }
          }
        } else {
          ref11 = enumerate(this.teams);
          for (v = 0, len9 = ref11.length; v < len9; v++) {
            [teamIndex, team] = ref11[v];
            center = (teamIndex + 0.5) / this.teams.length;
            width = 0.8 / this.teams.length;
            [left, right] = [center - width / 2, center + width / 2];
            for (weekIndex = z = 0, ref12 = FS_Data.epiweeks.length; (0 <= ref12 ? z < ref12 : z > ref12); weekIndex = 0 <= ref12 ? ++z : --z) {
              x = Point.blend(left, right, weekIndex / (FS_Data.epiweeks.length - 1));
              y = this.getY(teamValues[team][weekIndex]);
              this.points[team][weekIndex].setTarget(new PIXI.Point(x, y), animationProgress);
            }
          }
        }
        if (type === 'normal') {
          // start the animation
          this.animationStartTime = getTime();
        }
        return this.requestRender();
      }

      getY(value, p = 1) {
        var max, min, weight;
        weight = Point.ease(p);
        min = Point.blend(this.lastAxisMin, this.axisMin, weight);
        max = Point.blend(this.lastAxisMax, this.axisMax, weight);
        return 1 - (value - min) / (max - min);
      }

      lineMode() {
        return [this.lastMode, this.mode] = [this.mode, 'line'];
      }

      barMode() {
        return [this.lastMode, this.mode] = [this.mode, 'bar'];
      }

      resize(width, height) {
        this.renderer.resize(width, height);
        [this.w, this.h] = [width, height];
        return this.requestRender();
      }

      setPointsVisible(visible) {
        this.showPoints = visible;
        return this.requestRender();
      }

      shakeItUp() {
        var bar, dst, i, j, k, l, len, len1, point, rand, ref, ref1, ref2, t;
        rand = function() {
          return (Math.random() * 2 - 1) * 0.01;
        };
        this.lineOrder = _.shuffle(this.lineOrder);
        this.lastMode = this.mode;
        [this.lastDataMin, this.lastDataMax] = [this.dataMin, this.dataMax];
        [this.lastAxisMin, this.lastAxisMax] = [this.axisMin, this.axisMax];
        ref = this.teamBars;
        for (j = 0, len = ref.length; j < len; j++) {
          bar = ref[j];
          bar.src = bar.dst;
        }
        for (i = k = 0, ref1 = FS_Data.epiweeks.length; (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
          ref2 = this.teams;
          for (l = 0, len1 = ref2.length; l < len1; l++) {
            t = ref2[l];
            point = this.points[t][i];
            dst = point.dst;
            point.src = new PIXI.Point(dst.x + rand(), dst.y + rand());
          }
        }
        // start the animation
        this.animationStartTime = getTime();
        return this.requestRender();
      }

      setWili(wILI) {
        this.wILI = wILI;
        return this.requestRender();
      }

    };

    // defaults
    FS_Plot.animationDuration = 0.25;

    FS_Plot.colors = [0x4080c0, 0xc04080, 0xc08040, 0x40c080, 0x8040c0, 0x80c040];

    FS_Plot.labelStyle = {
      font: 'bold 32px Calibri'
    };

    FS_Plot.tickStyle = {
      font: '16px Calibri'
    };

    return FS_Plot;

  }).call(this);

}).call(this);
