// Generated by CoffeeScript 1.12.6
(function() {
  var Bar, FS_Plot, Point, enumerate, getTime, textMesh;

  enumerate = function(x) {
    var j, ref, results;
    return _.zip((function() {
      results = [];
      for (var j = 0, ref = x.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this), x);
  };

  getTime = function() {
    return new Date() * 1e-3;
  };

  textMesh = function(text, style) {
    var mesh;
    mesh = new PIXI.Text(text, style);
    mesh.anchor.set(0.5, 0.5);
    return mesh;
  };

  Point = (function() {
    Point.ease = function(p) {
      return (1 - Math.cos(Math.min(1, Math.max(0, p)) * Math.PI)) / 2;
    };

    Point.blend = function(a, b, weight) {
      return (1 - weight) * a + weight * b;
    };

    function Point(mesh1, loc) {
      var ref;
      this.mesh = mesh1;
      ref = [loc, loc], this.src = ref[0], this.dst = ref[1];
    }

    Point.prototype.setTarget = function(target, p) {
      var ref, weight, x, y;
      if (p == null) {
        p = 1;
      }
      weight = Point.ease(p);
      x = Point.blend(this.src.x, this.dst.x, weight);
      y = Point.blend(this.src.y, this.dst.y, weight);
      return ref = [new PIXI.Point(x, y), target], this.src = ref[0], this.dst = ref[1], ref;
    };

    Point.prototype.update = function(p, w, h) {
      var weight;
      weight = Point.ease(p);
      this.mesh.position.x = w * Point.blend(this.src.x, this.dst.x, weight);
      return this.mesh.position.y = h * Point.blend(this.src.y, this.dst.y, weight);
    };

    return Point;

  })();

  Bar = (function() {
    function Bar() {
      var ref;
      ref = [
        {
          mean: 0,
          std: 0
        }, {
          mean: 0,
          std: 0
        }
      ], this.src = ref[0], this.dst = ref[1];
    }

    Bar.prototype.setTarget = function(mean, std, p) {
      var mean0, ref, std0, weight;
      if (p == null) {
        p = 1;
      }
      weight = Point.ease(p);
      mean0 = Point.blend(this.src.mean, this.dst.mean, weight);
      std0 = Point.blend(this.src.std, this.dst.std, weight);
      return ref = [
        {
          mean: mean0,
          std: std0
        }, {
          mean: mean,
          std: std
        }
      ], this.src = ref[0], this.dst = ref[1], ref;
    };

    Bar.prototype.draw = function(p, plot, color, x, y, w, h) {
      var bar, barBottom, barMean, barTop, mean, ref, std, weight;
      weight = Point.ease(p);
      mean = Point.blend(this.src.mean, this.dst.mean, weight);
      std = Point.blend(this.src.std, this.dst.std, weight);
      barMean = y + plot.getY(mean, p) * h;
      barBottom = y + plot.getY(mean - std, p) * h;
      barTop = y + plot.getY(mean + std, p) * h;
      bar = new PIXI.Graphics();
      bar.lineStyle(0, 0, 0);
      bar.beginFill(color, 0.5);
      bar.drawRect(x - w / 2, barBottom, w, barTop - barBottom);
      bar.endFill();
      bar.lineStyle(3, color, 1);
      bar.moveTo(x - w / 2, barMean);
      bar.lineTo(x + w / 2, barMean);
      if ((ref = bar.currentPath) != null ? ref.shape : void 0) {
        bar.currentPath.shape.closed = false;
      }
      return bar;
    };

    return Bar;

  })();

  (typeof exports !== "undefined" && exports !== null ? exports : window).FS_Plot = FS_Plot = (function() {
    FS_Plot.animationDuration = 0.25;

    FS_Plot.colors = [0x4080c0, 0xc04080, 0xc08040, 0x40c080, 0x8040c0, 0x80c040];

    FS_Plot.labelStyle = {
      font: 'bold 32px Calibri'
    };

    FS_Plot.tickStyle = {
      font: '16px Calibri'
    };

    function FS_Plot(canvas, teams1) {
      var count, ew, graphics, i, j, k, l, len, len1, len2, len3, len4, m, mesh, n, o, options, point0, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, style, team, y_label;
      this.teams = teams1;
      this.xTicks = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = FS_Data.epiweeks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push((i + 0.5) / FS_Data.epiweeks.length);
        }
        return results;
      })();
      ref = [canvas.width(), canvas.height()], this.w = ref[0], this.h = ref[1];
      options = {
        view: canvas[0],
        antialias: true
      };
      this.renderer = new PIXI.autoDetectRenderer(this.w, this.h, options);
      this.renderer.backgroundColor = 0xffffff;
      this.teamColors = {};
      ref1 = enumerate(this.teams);
      for (j = 0, len = ref1.length; j < len; j++) {
        ref2 = ref1[j], i = ref2[0], team = ref2[1];
        this.teamColors[team] = FS_Plot.colors[i % FS_Plot.colors.length];
      }
      this.showPoints = false;
      this.showLegend = true;
      this.stageTeamPoints = {};
      point0 = new PIXI.Point(0.5, 0.5);
      this.points = {};
      ref3 = this.teams;
      for (k = 0, len1 = ref3.length; k < len1; k++) {
        team = ref3[k];
        this.points[team] = [];
        this.stageTeamPoints[team] = new PIXI.Container();
        count = 0;
        ref4 = FS_Data.epiweeks;
        for (l = 0, len2 = ref4.length; l < len2; l++) {
          ew = ref4[l];
          graphics = new PIXI.Graphics();
          graphics.beginFill(this.teamColors[team], 1);
          graphics.lineStyle(2, 0x000000, 1);
          graphics.drawCircle(0, 0, 4);
          graphics.endFill();
          this.stageTeamPoints[team].addChild(graphics);
          this.points[team].push(new Point(graphics, point0));
          count = count + 1;
        }
      }
      this.lineOrder = (function() {
        results = [];
        for (var m = 0, ref5 = this.teams.length; 0 <= ref5 ? m < ref5 : m > ref5; 0 <= ref5 ? m++ : m--){ results.push(m); }
        return results;
      }).apply(this);
      this.teamBars = [];
      ref6 = this.teams;
      for (n = 0, len3 = ref6.length; n < len3; n++) {
        team = ref6[n];
        this.teamBars.push(new Bar());
      }
      this.renderRequested = false;
      this.lastMode = this.mode = 'line';
      ref7 = [-1, +1], this.plotMin = ref7[0], this.plotMax = ref7[1];
      ref8 = [-1, +1], this.dataMin = ref8[0], this.dataMax = ref8[1];
      ref9 = [-1.1, +1.1], this.axisMin = ref9[0], this.axisMax = ref9[1];
      y_label = textMesh('AE/LS', FS_Plot.labelStyle);
      this.axisLabels = {
        line: {
          x: textMesh('Epiweek', FS_Plot.labelStyle),
          y: y_label
        },
        bar: {
          x: textMesh('Team', FS_Plot.labelStyle),
          y: y_label
        }
      };
      this.axisTicks = {
        line: {
          x: (function() {
            var len4, o, ref10, results1;
            ref10 = FS_Data.epiweeks;
            results1 = [];
            for (o = 0, len4 = ref10.length; o < len4; o++) {
              ew = ref10[o];
              results1.push(textMesh('' + ew, FS_Plot.tickStyle));
            }
            return results1;
          })()
        },
        bar: {
          x: (function() {
            var len4, o, ref10, results1;
            ref10 = this.teams;
            results1 = [];
            for (o = 0, len4 = ref10.length; o < len4; o++) {
              team = ref10[o];
              results1.push(textMesh(team, FS_Plot.tickStyle));
            }
            return results1;
          }).call(this)
        }
      };
      this.legend = new PIXI.Container();
      ref10 = enumerate(this.teams);
      for (o = 0, len4 = ref10.length; o < len4; o++) {
        ref11 = ref10[o], i = ref11[0], team = ref11[1];
        style = {
          font: FS_Plot.tickStyle.font,
          fill: this.teamColors[team]
        };
        mesh = textMesh(team, style);
        mesh.position.set(mesh.width / 2, 16 * (i + 1));
        this.legend.addChild(mesh);
      }
      this.wILI = null;
      this.animationStartTime = getTime();
    }

    FS_Plot.prototype.requestRender = function() {
      if (this.renderRequested) {
        return;
      }
      this.renderRequested = true;
      return requestAnimationFrame((function(_this) {
        return function(renderTime) {
          return _this.render(renderTime);
        };
      })(this));
    };

    FS_Plot.prototype.render = function(renderTime) {
      var alpha, animationProgress, axes, b, bar, color, dataMax, dataMin, h, i, j, k, l, len, len1, len2, len3, len4, len5, line, lineWidth, m, n, o, overlay, p, plotBox, pts, q, r, range, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, stageLines, stageMain, stagePlot, str, t, team, teamIndex, tickLabel, tickLabels, u, value, w, weight, x, x0, x1, xBox, y, y0, y1, yBox;
      this.renderRequested = false;
      animationProgress = (getTime() - this.animationStartTime) / FS_Plot.animationDuration;
      if (animationProgress < 1) {
        this.requestRender();
      }
      yBox = {
        x: 0,
        y: 0,
        w: 64,
        h: this.h
      };
      plotBox = {
        x: yBox.w,
        y: 0,
        w: this.w - yBox.w,
        h: this.h - 32
      };
      xBox = {
        x: plotBox.x,
        y: plotBox.y + plotBox.h,
        w: this.w - plotBox.x,
        h: this.h - (plotBox.y + plotBox.h)
      };
      stagePlot = new PIXI.Container();
      stagePlot.position.set(plotBox.x, plotBox.y);
      if (this.wILI !== null && this.wILI.length > 0) {
        line = new PIXI.Graphics();
        line.lineStyle(3, 0x000000, 0.25);
        for (i = j = 1, ref = this.wILI.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          h = i - 1;
          x0 = this.xTicks[h] * plotBox.w;
          x1 = this.xTicks[i] * plotBox.w;
          y0 = this.getY(Point.blend(this.dataMin, this.dataMax, this.wILI[h])) * plotBox.h;
          y1 = this.getY(Point.blend(this.dataMin, this.dataMax, this.wILI[i])) * plotBox.h;
          line.moveTo(x0, y0);
          line.lineTo(x1, y1);
          if ((ref1 = line.currentPath) != null ? ref1.shape : void 0) {
            line.currentPath.shape.closed = false;
          }
        }
        stagePlot.addChild(line);
      }
      ref2 = this.teams;
      for (k = 0, len = ref2.length; k < len; k++) {
        t = ref2[k];
        ref3 = this.points[t];
        for (l = 0, len1 = ref3.length; l < len1; l++) {
          p = ref3[l];
          p.update(animationProgress, plotBox.w, plotBox.h);
        }
      }
      stageLines = new PIXI.Container();
      ref4 = this.lineOrder;
      for (m = 0, len2 = ref4.length; m < len2; m++) {
        teamIndex = ref4[m];
        team = this.teams[teamIndex];
        line = new PIXI.Graphics();
        alpha = this.showPoints ? 0.75 : 1;
        line.lineStyle(3, this.teamColors[team], alpha);
        pts = this.points[team];
        for (i = n = 1, ref5 = pts.length; 1 <= ref5 ? n < ref5 : n > ref5; i = 1 <= ref5 ? ++n : --n) {
          h = i - 1;
          line.moveTo(pts[h].mesh.position.x, pts[h].mesh.position.y);
          line.lineTo(pts[i].mesh.position.x, pts[i].mesh.position.y);
          if ((ref6 = line.currentPath) != null ? ref6.shape : void 0) {
            line.currentPath.shape.closed = false;
          }
        }
        stageLines.addChild(line);
      }
      stagePlot.addChild(stageLines);
      if (this.showPoints) {
        ref7 = this.lineOrder;
        for (o = 0, len3 = ref7.length; o < len3; o++) {
          teamIndex = ref7[o];
          stagePlot.addChild(this.stageTeamPoints[this.teams[teamIndex]]);
        }
      }
      tickLabels = new PIXI.Container();
      axes = new PIXI.Graphics();
      overlay = new PIXI.Graphics();
      axes.lineStyle(3, 0x000000, 1);
      x0 = xBox.x + this.xTicks[0] * xBox.w;
      x1 = xBox.x + this.xTicks[this.xTicks.length - 1] * xBox.w;
      y0 = plotBox.y + this.getY(this.dataMin) * plotBox.h;
      y1 = plotBox.y + this.getY(this.dataMax) * plotBox.h;
      axes.moveTo(plotBox.x, y0);
      axes.lineTo(plotBox.x, y1);
      axes.moveTo(x0, xBox.y);
      axes.lineTo(x1, xBox.y);
      if ((ref8 = axes.currentPath) != null ? ref8.shape : void 0) {
        axes.currentPath.shape.closed = false;
      }
      weight = Point.ease(animationProgress);
      dataMin = Point.blend(this.lastDataMin, this.dataMin, weight);
      dataMax = Point.blend(this.lastDataMax, this.dataMax, weight);
      this.interval = 1;
      range = dataMax - dataMin;
      while (this.interval >= 0.01 && range / this.interval < 6) {
        this.interval *= 0.5;
      }
      while (this.interval < 100 && range / this.interval >= 12) {
        this.interval *= 2;
      }
      for (i = q = 0, ref9 = range / this.interval; 0 <= ref9 ? q <= ref9 : q >= ref9; i = 0 <= ref9 ? ++q : --q) {
        value = this.dataMin + i * this.interval;
        x = plotBox.x;
        y = plotBox.y + this.getY(value, animationProgress) * plotBox.h;
        str = value.toFixed(2);
        while (str.indexOf('.') >= 0 && (str.endsWith('0') || str.endsWith('.'))) {
          str = str.substring(0, str.length - 1);
        }
        tickLabel = textMesh(str, FS_Plot.tickStyle);
        tickLabel.position.set(x - tickLabel.width / 2 - 15, y);
        tickLabels.addChild(tickLabel);
        axes.lineStyle(1, 0x000000, 0.1);
        axes.moveTo(x0, y);
        axes.lineTo(x1, y);
        axes.lineStyle(3, 0x000000, 1);
        axes.moveTo(x, y);
        axes.lineTo(x - 10, y);
      }
      if (this.mode === 'line') {
        for (i = r = 0, ref10 = FS_Data.epiweeks.length; 0 <= ref10 ? r < ref10 : r > ref10; i = 0 <= ref10 ? ++r : --r) {
          ref11 = [xBox.x + this.xTicks[i] * xBox.w, xBox.y], x = ref11[0], y = ref11[1];
          if (i % 3 === 0) {
            lineWidth = 3;
            tickLabel = this.axisTicks[this.mode].x[i];
            tickLabel.position.set(x, y + 20);
            tickLabels.addChild(tickLabel);
          } else {
            lineWidth = 1;
          }
          axes.lineStyle(1, 0x000000, 0.1);
          axes.moveTo(x, y0);
          axes.lineTo(x, y1);
          if ((ref12 = axes.currentPath) != null ? ref12.shape : void 0) {
            axes.currentPath.shape.closed = false;
          }
          axes.lineStyle(lineWidth, 0x000000, 1);
          axes.moveTo(x, y);
          axes.lineTo(x, y + 10);
          if ((ref13 = axes.currentPath) != null ? ref13.shape : void 0) {
            axes.currentPath.shape.closed = false;
          }
        }
      } else {
        ref14 = enumerate(this.teams);
        for (s = 0, len4 = ref14.length; s < len4; s++) {
          ref15 = ref14[s], i = ref15[0], team = ref15[1];
          ref16 = [xBox.x + (i + 0.5) / this.teams.length * xBox.w, xBox.y], x = ref16[0], y = ref16[1];
          tickLabel = this.axisTicks[this.mode].x[i];
          tickLabel.position.set(x, y + 20);
          tickLabels.addChild(tickLabel);
          axes.lineStyle(1, 0x000000, 0.1);
          axes.moveTo(x, y0);
          axes.lineTo(x, y1);
          if ((ref17 = axes.currentPath) != null ? ref17.shape : void 0) {
            axes.currentPath.shape.closed = false;
          }
          axes.lineStyle(3, 0x000000, 1);
          axes.moveTo(x, y);
          axes.lineTo(x, y + 10);
          if ((ref18 = axes.currentPath) != null ? ref18.shape : void 0) {
            axes.currentPath.shape.closed = false;
          }
        }
      }
      if (this.mode !== 'line' || this.lastMode !== 'line') {
        ref19 = enumerate(this.teamBars);
        for (u = 0, len5 = ref19.length; u < len5; u++) {
          ref20 = ref19[u], i = ref20[0], bar = ref20[1];
          ref21 = [xBox.x + (i + 0.5) / this.teams.length * xBox.w, plotBox.y], x = ref21[0], y = ref21[1];
          ref22 = [0.9 / this.teams.length * plotBox.w, plotBox.h], w = ref22[0], h = ref22[1];
          color = this.teamColors[this.teams[i]];
          p = animationProgress;
          b = bar.draw(p, this, color, x, y, w, h);
          if (this.lastMode !== this.mode) {
            if (this.mode === 'line') {
              p = 1 - animationProgress;
            } else {
              p = animationProgress;
            }
            b.alpha = Point.ease(p);
          } else {
            bar.alpha = 1;
          }
          overlay.addChild(b);
        }
      }
      this.legend.position.set(plotBox.x + plotBox.w - this.legend.width - 8, plotBox.y);
      stageMain = new PIXI.Container();
      stageMain.addChild(tickLabels);
      stageMain.addChild(axes);
      stageMain.addChild(stagePlot);
      stageMain.addChild(overlay);
      if (this.showLegend) {
        stageMain.addChild(this.legend);
      }
      return this.renderer.render(stageMain);
    };

    FS_Plot.prototype.update = function(teamValues, type, teams, colors) {
      var animationProgress, center, count, diff, dist, ew, graphics, i, i1, j, k, l, left, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, max, mesh, min, n, o, padding, point0, q, r, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, right, s, style, sum, t, team, teamIndex, u, v, value, weekIndex, width, x, y, z;
      if (type == null) {
        type = 'normal';
      }
      this.teams = teams;
      this.colors = colors;
      ref = [0, 0], min = ref[0], max = ref[1];
      this.teamAverages = {};
      this.teamStds = {};
      this.teamBars = [];
      ref1 = this.teams;
      for (j = 0, len = ref1.length; j < len; j++) {
        team = ref1[j];
        this.teamBars.push(new Bar());
      }
      ref2 = enumerate(this.teams);
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        ref3 = ref2[k], i = ref3[0], t = ref3[1];
        sum = 0;
        ref4 = teamValues[t];
        for (l = 0, len2 = ref4.length; l < len2; l++) {
          value = ref4[l];
          min = Math.min(min, value);
          max = Math.max(max, value);
          sum += value;
        }
        this.teamAverages[t] = sum / teamValues[t].length;
        sum = 0;
        ref5 = teamValues[t];
        for (m = 0, len3 = ref5.length; m < len3; m++) {
          value = ref5[m];
          sum += Math.pow(value - this.teamAverages[t], 2);
        }
        this.teamStds[t] = Math.pow(sum / teamValues[t].length, 0.5);
        this.teamBars[i].setTarget(this.teamAverages[t], this.teamStds[t]);
      }
      if (type === 'zoomIn') {
        dist = this.dataMax - this.dataMin;
        diff = dist / 8.0;
        ref6 = [this.dataMin + diff, this.dataMax - diff], min = ref6[0], max = ref6[1];
      }
      if (type === 'zoomOut') {
        dist = this.dataMax - this.dataMin;
        diff = dist * 2.0 / 3.0;
        ref7 = [this.dataMin - this.interval, this.dataMax + this.interval], min = ref7[0], max = ref7[1];
      }
      if (type === 'moveUp') {
        dist = this.interval;
        ref8 = [this.dataMin + dist, this.dataMax + dist], min = ref8[0], max = ref8[1];
      }
      if (type === 'moveDown') {
        dist = this.interval;
        ref9 = [this.dataMin - dist, this.dataMax - dist], min = ref9[0], max = ref9[1];
      }
      if (type === 'teamToggle') {
        ref10 = [this.dataMin, this.dataMax], min = ref10[0], max = ref10[1];
      }
      if (type === 'legendToggle') {
        this.showLegend = !this.showLegend;
        ref11 = [this.dataMin, this.dataMax], min = ref11[0], max = ref11[1];
      }
      padding = (max - min) * 0.05;
      ref12 = [this.dataMin, this.dataMax], this.lastDataMin = ref12[0], this.lastDataMax = ref12[1];
      ref13 = [this.axisMin, this.axisMax], this.lastAxisMin = ref13[0], this.lastAxisMax = ref13[1];
      ref14 = [min, max], this.dataMin = ref14[0], this.dataMax = ref14[1];
      ref15 = [min - padding, max + padding], this.axisMin = ref15[0], this.axisMax = ref15[1];
      this.teamColors = {};
      ref16 = enumerate(this.teams);
      for (n = 0, len4 = ref16.length; n < len4; n++) {
        ref17 = ref16[n], i = ref17[0], team = ref17[1];
        this.teamColors[team] = this.colors[i % this.colors.length];
      }
      this.lineOrder = (function() {
        results = [];
        for (var o = 0, ref18 = this.teams.length; 0 <= ref18 ? o < ref18 : o > ref18; 0 <= ref18 ? o++ : o--){ results.push(o); }
        return results;
      }).apply(this);
      this.stageTeamPoints = {};
      point0 = new PIXI.Point(0.5, 0.5);
      this.points = {};
      ref19 = this.teams;
      for (q = 0, len5 = ref19.length; q < len5; q++) {
        team = ref19[q];
        this.points[team] = [];
        this.stageTeamPoints[team] = new PIXI.Container();
        count = 0;
        ref20 = FS_Data.epiweeks;
        for (r = 0, len6 = ref20.length; r < len6; r++) {
          ew = ref20[r];
          graphics = new PIXI.Graphics();
          graphics.beginFill(this.teamColors[team], 1);
          graphics.lineStyle(2, 0x000000, 1);
          graphics.drawCircle(0, 0, 4);
          graphics.endFill();
          if (teamValues[team][count] >= min) {
            this.stageTeamPoints[team].addChild(graphics);
          }
          this.points[team].push(new Point(graphics, point0));
          count = count + 1;
        }
      }
      this.axisTicks = {
        line: {
          x: (function() {
            var len7, ref21, results1, s;
            ref21 = FS_Data.epiweeks;
            results1 = [];
            for (s = 0, len7 = ref21.length; s < len7; s++) {
              ew = ref21[s];
              results1.push(textMesh('' + ew, FS_Plot.tickStyle));
            }
            return results1;
          })()
        },
        bar: {
          x: (function() {
            var len7, ref21, results1, s;
            ref21 = this.teams;
            results1 = [];
            for (s = 0, len7 = ref21.length; s < len7; s++) {
              team = ref21[s];
              results1.push(textMesh(team, FS_Plot.tickStyle));
            }
            return results1;
          }).call(this)
        }
      };
      this.legend = new PIXI.Container();
      ref21 = enumerate(this.teams);
      for (s = 0, len7 = ref21.length; s < len7; s++) {
        ref22 = ref21[s], i = ref22[0], team = ref22[1];
        style = {
          font: FS_Plot.tickStyle.font,
          fill: this.teamColors[team]
        };
        mesh = textMesh(team, style);
        mesh.position.set(mesh.width / 2, 16 * (i + 1));
        this.legend.addChild(mesh);
      }
      animationProgress = (getTime() - this.animationStartTime) / FS_Plot.animationDuration;
      if (this.mode === 'line') {
        for (i = u = 0, ref23 = FS_Data.epiweeks.length; 0 <= ref23 ? u < ref23 : u > ref23; i = 0 <= ref23 ? ++u : --u) {
          x = this.xTicks[i];
          ref24 = this.teams;
          for (v = 0, len8 = ref24.length; v < len8; v++) {
            t = ref24[v];
            y = this.getY(teamValues[t][i]);
            this.points[t][i].setTarget(new PIXI.Point(x, y), animationProgress);
          }
        }
      } else {
        ref25 = enumerate(this.teams);
        for (z = 0, len9 = ref25.length; z < len9; z++) {
          ref26 = ref25[z], teamIndex = ref26[0], team = ref26[1];
          center = (teamIndex + 0.5) / this.teams.length;
          width = 0.8 / this.teams.length;
          ref27 = [center - width / 2, center + width / 2], left = ref27[0], right = ref27[1];
          for (weekIndex = i1 = 0, ref28 = FS_Data.epiweeks.length; 0 <= ref28 ? i1 < ref28 : i1 > ref28; weekIndex = 0 <= ref28 ? ++i1 : --i1) {
            x = Point.blend(left, right, weekIndex / (FS_Data.epiweeks.length - 1));
            y = this.getY(teamValues[team][weekIndex]);
            this.points[team][weekIndex].setTarget(new PIXI.Point(x, y), animationProgress);
          }
        }
      }
      if (type === 'normal') {
        this.animationStartTime = getTime();
      }
      return this.requestRender();
    };

    FS_Plot.prototype.getY = function(value, p) {
      var max, min, weight;
      if (p == null) {
        p = 1;
      }
      weight = Point.ease(p);
      min = Point.blend(this.lastAxisMin, this.axisMin, weight);
      max = Point.blend(this.lastAxisMax, this.axisMax, weight);
      return 1 - (value - min) / (max - min);
    };

    FS_Plot.prototype.lineMode = function() {
      var ref;
      return ref = [this.mode, 'line'], this.lastMode = ref[0], this.mode = ref[1], ref;
    };

    FS_Plot.prototype.barMode = function() {
      var ref;
      return ref = [this.mode, 'bar'], this.lastMode = ref[0], this.mode = ref[1], ref;
    };

    FS_Plot.prototype.resize = function(width, height) {
      var ref;
      this.renderer.resize(width, height);
      ref = [width, height], this.w = ref[0], this.h = ref[1];
      return this.requestRender();
    };

    FS_Plot.prototype.setPointsVisible = function(visible) {
      this.showPoints = visible;
      return this.requestRender();
    };

    FS_Plot.prototype.shakeItUp = function() {
      var bar, dst, i, j, k, l, len, len1, point, rand, ref, ref1, ref2, ref3, ref4, t;
      rand = function() {
        return (Math.random() * 2 - 1) * 0.01;
      };
      this.lineOrder = _.shuffle(this.lineOrder);
      this.lastMode = this.mode;
      ref = [this.dataMin, this.dataMax], this.lastDataMin = ref[0], this.lastDataMax = ref[1];
      ref1 = [this.axisMin, this.axisMax], this.lastAxisMin = ref1[0], this.lastAxisMax = ref1[1];
      ref2 = this.teamBars;
      for (j = 0, len = ref2.length; j < len; j++) {
        bar = ref2[j];
        bar.src = bar.dst;
      }
      for (i = k = 0, ref3 = FS_Data.epiweeks.length; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
        ref4 = this.teams;
        for (l = 0, len1 = ref4.length; l < len1; l++) {
          t = ref4[l];
          point = this.points[t][i];
          dst = point.dst;
          point.src = new PIXI.Point(dst.x + rand(), dst.y + rand());
        }
      }
      this.animationStartTime = getTime();
      return this.requestRender();
    };

    FS_Plot.prototype.setWili = function(wILI) {
      this.wILI = wILI;
      return this.requestRender();
    };

    return FS_Plot;

  })();

}).call(this);
